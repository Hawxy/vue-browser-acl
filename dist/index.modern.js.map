{"version":3,"file":"index.modern.js","sources":["../index.ts"],"sourcesContent":["import Acl from 'browser-acl'\nimport { Verb, Subject } from 'browser-acl/types'\nimport { VueConstructor, VNode, DirectiveFunction } from 'vue/types'\nimport { DirectiveBinding } from 'vue/types/options'\nimport VueRouter, { Route } from 'vue-router/types'\nimport {\n  AclWithRouter,\n  CompiledOptions,\n  Options,\n  PromiseChain,\n  SetupCallback,\n  User,\n  UserGetter,\n  VueRouterMeta,\n} from './index.d'\n\n/**\n * VueAcl\n *\n * ```javascript\n * import Vue from 'vue'\n * import Acl from 'vue-browser-acl'\n *\n * Vue.use(Acl, user, (acl) => {\n *   acl.rule(view, Post)\n *   acl.rule([edit, delete], Post, (user, post) => post.userId === user.id)\n *   acl.rule('moderate', Post, (user) => user.isModerator())\n * })\n * ```\n */\nclass VueAcl {\n  install(\n    Vue: VueConstructor,\n    user: User | UserGetter,\n    aclOrSetupCallback: Acl | SetupCallback | undefined = undefined,\n    options: Options = {},\n  ): void {\n    const userAccessor: Function =\n      typeof user === 'function' ? user : () => user\n\n    /* defaults */\n    const strict = Boolean(options.strict)\n\n    const opt: CompiledOptions = Object.assign(\n      {\n        acl: { strict },\n        aliases: ['role'],\n        assumeGlobal: !strict,\n        caseMode: true,\n        debug: false,\n        directive: 'can',\n        failRoute: '/',\n        helper: true,\n        strict: false,\n      },\n      options,\n    )\n\n    const findCan = findCanWithOptions(opt)\n\n    /* setup acl */\n    let acl: AclWithRouter = new Acl(opt.acl) as AclWithRouter\n    if (typeof aclOrSetupCallback === 'function') {\n      aclOrSetupCallback(acl)\n    } else if (aclOrSetupCallback instanceof Acl) {\n      acl = aclOrSetupCallback\n    }\n\n    /* router init function */\n    acl.router = function (router: VueRouter) {\n      opt.router = router\n\n      const canNavigate = (\n        verb: string,\n        subject: string | null,\n        ...otherArgs: any[]\n      ) => {\n        return (\n          (subject && acl.can(userAccessor(), verb, subject, ...otherArgs)) ||\n          (!subject && !opt.strict)\n        )\n      }\n\n      /* convert 'edit Post' to ['edit', 'Post'] */\n      const aclTuple = (value: string): [string, string | null] => {\n        const [\n          verb,\n          subject = opt.assumeGlobal ? Acl.GlobalRule : null,\n        ] = value.split(' ')\n        return [verb, subject]\n      }\n\n      /**\n       * chain all can-statements and functions as promises\n       * each can-function must return a promise (in strict\n       * mode at least). To break the chain return a none\n       * true value\n       */\n      const chainCans = (\n        metas: VueRouterMeta[],\n        to: Route,\n        from: Route,\n      ): PromiseChain => {\n        let fail: string | null = null\n        const chain: PromiseChain = metas.reduce((chain, meta) => {\n          return (\n            chain\n              .then((result: any) => {\n                if (result !== true) {\n                  return result\n                }\n\n                if (typeof meta.fail === 'string') {\n                  fail = meta.fail\n                }\n\n                const can = findCan(meta)\n\n                const nextPromise =\n                  typeof can === 'function'\n                    ? can(to, from, canNavigate)\n                    : Promise.resolve(canNavigate(...aclTuple(can)))\n\n                if (opt.strict && !(nextPromise instanceof Promise)) {\n                  throw new Error(\n                    '$route.meta.can must return a promise in strict mode',\n                  )\n                }\n\n                return nextPromise\n              })\n              // convert errors to false\n              .catch((error) => {\n                if (opt.debug) {\n                  console.error(error)\n                }\n                return false\n              })\n          )\n        }, Promise.resolve(true)) as PromiseChain\n        chain.getFail = () => fail\n        return chain\n      }\n\n      router.beforeEach((to: Route, from: Route, next: any) => {\n        const metas = to.matched\n          .filter((route) => route.meta && findCan(route.meta))\n          .map((route) => route.meta)\n\n        const chain = chainCans(metas, to, from)\n\n        chain.then((result) => {\n          if (result === true) {\n            return next()\n          }\n\n          let fail: string | Function | null = chain.getFail() || opt.failRoute\n\n          if (fail === '$from') {\n            fail = from.path\n          }\n\n          next(typeof fail === 'function' ? fail(to, from) : fail)\n        })\n      })\n    }\n\n    /* init router */\n    if (opt.router) {\n      acl.router(opt.router)\n    }\n\n    /* directive update handler */\n    const directiveHandler: DirectiveFunction = function (\n      el: HTMLElement,\n      binding: DirectiveBinding,\n      vnode: VNode,\n    ): void {\n      const behaviour: Behaviour = getBehaviour(binding.modifiers)\n\n      let verb, verbArg, subject, params\n      verbArg = binding.arg\n\n      if (Array.isArray(binding.value) && binding.expression.startsWith('[')) {\n        ;[verb, subject, params] = binding.modifiers.global\n          ? arrayToGlobalExprTpl(binding)\n          : arrayToExprTpl(binding)\n      } else if (typeof binding.value === 'string') {\n        ;[verb, subject, params] = stringToExprTpl(binding, vnode, opt)\n      } else if (verbArg && typeof binding.value === 'object') {\n        verb = verbArg\n        subject = binding.value\n        params = []\n      } else if (\n        binding.value === undefined &&\n        !binding.modifiers.global &&\n        opt.assumeGlobal\n      ) {\n        // Fall back to global if no value is provided\n        verb = verbArg\n        subject = Acl.GlobalRule\n        params = []\n      }\n\n      if (opt.assumeGlobal && !subject) {\n        subject = Acl.GlobalRule\n        params = params || []\n        verb = verb || verbArg\n      }\n\n      if (!verb || !subject) {\n        throw new Error('Missing verb or subject')\n      }\n\n      const aclMethod =\n        (binding.modifiers.some && 'some') ||\n        (binding.modifiers.every && 'every') ||\n        'can'\n\n      const ok = acl[aclMethod](userAccessor(), verb, subject, ...params)\n      const not = binding.modifiers.not\n\n      const elDisabled: HasDisabledElement | false = supportsDisabled(el)\n      const elReadOnly: HasReadOnlyElement | false = supportsReadOnly(el)\n\n      if (elDisabled) {\n        elDisabled.disabled = false\n      }\n\n      if (elReadOnly) {\n        elReadOnly.readOnly = false\n      }\n\n      if ((ok && not) || (!ok && !not)) {\n        if (behaviour === 'hide') {\n          commentNode(el, vnode)\n        } else if (behaviour === 'disable' && elDisabled) {\n          elDisabled.disabled = true\n        } else if (behaviour === 'readonly' && elReadOnly) {\n          elReadOnly.readOnly = true\n        }\n      }\n    }\n\n    /* set up directive for 'can' and aliases */\n    const directiveNames = [opt.directive, ...opt.aliases]\n    directiveNames.forEach((name) => Vue.directive(name, directiveHandler))\n\n    /* define helpers */\n    if (opt.helper) {\n      const helper = `$${opt.directive}`\n      Vue.prototype[helper] = function (\n        verb: Verb,\n        subject: Subject,\n        ...args: any[]\n      ) {\n        return acl.can(userAccessor(), verb, subject, ...args)\n      }\n      Vue.prototype[helper].not = function (\n        verb: Verb,\n        subject: Subject,\n        ...args: any[]\n      ) {\n        return !acl.can(userAccessor(), verb, subject, ...args)\n      }\n      Vue.prototype[helper].every = function (\n        verb: Verb,\n        subjects: Subject[],\n        ...args: any[]\n      ) {\n        return acl.every(userAccessor(), verb, subjects, ...args)\n      }\n      Vue.prototype[helper].some = function (\n        verb: Verb,\n        subjects: Subject[],\n        ...args: any[]\n      ) {\n        return acl.some(userAccessor(), verb, subjects, ...args)\n      }\n    }\n  }\n}\n\ntype Behaviour = 'disable' | 'readonly' | 'hide'\n\nfunction getBehaviour(modifiers: any): Behaviour {\n  if (typeof modifiers.disable !== 'undefined') {\n    return 'disable'\n  }\n  if (typeof modifiers.readonly !== 'undefined') {\n    return 'readonly'\n  }\n  return 'hide'\n}\n\ninterface HasDisabledElement extends HTMLElement {\n  disabled: string | boolean\n}\n\nconst disabledTypes = [\n  HTMLButtonElement,\n  HTMLFieldSetElement,\n  HTMLInputElement,\n  HTMLOptGroupElement,\n  HTMLOptionElement,\n  HTMLSelectElement,\n  HTMLTextAreaElement,\n]\n\nfunction supportsDisabled(el: HTMLElement): HasDisabledElement | false {\n  if (disabledTypes.some((type) => el instanceof type)) {\n    return el as HasDisabledElement\n  }\n  return false\n}\n\ninterface HasReadOnlyElement extends HTMLElement {\n  readOnly: string | boolean\n}\n\nconst readOnlyTypes = [HTMLInputElement, HTMLTextAreaElement]\n\nfunction supportsReadOnly(el: HTMLElement): HasReadOnlyElement | false {\n  if (readOnlyTypes.some((type) => el instanceof type)) {\n    return el as HasReadOnlyElement\n  }\n  return false\n}\n\n/**\n * Create comment node\n *\n * @private\n * @author https://stackoverflow.com/questions/43003976/a-custom-directive-similar-to-v-if-in-vuejs#43543814\n */\nfunction commentNode(el: HTMLElement, vnode: VNode) {\n  const comment = document.createComment(' ')\n\n  Object.defineProperty(comment, 'setAttribute', {\n    value: () => undefined,\n  })\n\n  vnode.text = ' '\n  vnode.elm = comment\n  vnode.isComment = true\n  vnode.tag = undefined\n\n  vnode.data = vnode.data || {}\n  vnode.data.directives = undefined\n\n  if (vnode.componentInstance) {\n    // @ts-ignore\n    vnode.componentInstance.$el = comment\n  }\n\n  if (el.parentNode) {\n    el.parentNode.replaceChild(comment, el)\n  }\n}\n\n/**\n * Return the first property from meta that is 'can' or one of its aliases.\n */\nconst findCanWithOptions = (opt: CompiledOptions) => (\n  meta: VueRouterMeta,\n): string | Function => {\n  return ([opt.directive, ...(opt.aliases || [])] as string[])\n    .map((key: string) => meta[key])\n    .filter(Boolean)\n    .shift()\n}\n\n/**\n * Maps binding.value of type array to expression tuple\n */\nconst arrayToExprTpl = ({ arg, value }: DirectiveBinding) => [\n  arg || value[0],\n  arg ? value[0] : value[1],\n  arg ? value.slice(1) : value.slice(2),\n]\n\n/**\n * Maps binding.value of type array to global expression tuple\n */\nconst arrayToGlobalExprTpl = ({ arg, value }: DirectiveBinding) => [\n  arg || value[0],\n  Acl.GlobalRule,\n  arg ? value : value.slice(1),\n]\n\n/**\n * Maps binding.value of type string to expression tuple\n */\nconst stringToExprTpl = (\n  { arg, value, modifiers }: DirectiveBinding,\n  vnode: VNode,\n  opt: CompiledOptions,\n) => {\n  let [verb, subject] = arg ? [arg, value] : value.split(' ')\n\n  if (subject && modifiers.global) {\n    throw new Error(\n      'You cannot provide subject and use global modifier at the same time',\n    )\n  }\n\n  if (\n    typeof subject === 'string' &&\n    opt.caseMode &&\n    subject[0].match(/[a-z]/) &&\n    typeof vnode.context === 'object'\n  ) {\n    subject = vnode.context.$data[subject]\n  }\n\n  return [verb, subject, []]\n}\n\nexport default VueAcl\n"],"names":["disabledTypes","HTMLButtonElement","HTMLFieldSetElement","HTMLInputElement","HTMLOptGroupElement","HTMLOptionElement","HTMLSelectElement","HTMLTextAreaElement","readOnlyTypes","install","Vue","user","aclOrSetupCallback","options","userAccessor","strict","Boolean","opt","Object","assign","acl","aliases","assumeGlobal","caseMode","debug","directive","failRoute","helper","findCan","meta","map","key","filter","shift","findCanWithOptions","Acl","router","canNavigate","verb","subject","otherArgs","can","beforeEach","to","from","next","chain","metas","fail","reduce","then","result","nextPromise","Promise","resolve","value","GlobalRule","split","aclTuple","Error","catch","error","console","getFail","chainCans","matched","route","path","directiveHandler","el","binding","vnode","behaviour","modifiers","disable","readonly","verbArg","params","arg","Array","isArray","expression","startsWith","global","slice","arrayToGlobalExprTpl","arrayToExprTpl","match","context","$data","stringToExprTpl","undefined","ok","some","every","not","elDisabled","type","supportsDisabled","elReadOnly","supportsReadOnly","disabled","readOnly","comment","document","createComment","defineProperty","text","elm","isComment","tag","data","directives","componentInstance","$el","parentNode","replaceChild","commentNode","forEach","name","prototype","args","subjects"],"mappings":"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"}